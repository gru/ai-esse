# ИИ для разработчика. Часть 1. Шаблон.

В последнее время искусственный интеллект (ИИ) стал одной из самых обсуждаемых тем в мире технологий. Несмотря на растущий интерес к этой области, я долгое время оставался в стороне от этого тренда. Однако недавно моё внимание привлекло видео известного разработчика Дмитрия Нестерука, в котором он рассказывает о применении ИИ в своей повседневной работе.

Хотя видео Дмитрия не содержало конкретных практических примеров, оно заставило меня задуматься о потенциале ИИ в сфере разработки. Особенно меня заинтересовал его вывод о том, что ИИ можно рассматривать как "автодополнение на стероидах", а интеграция ИИ в рабочий процесс способна значительно повысить продуктивность разработчиков, в некоторых случаях увеличивая её в разы.

В своей статье я хочу поделиться своим опытом использования ИИ в разработке и проанализировать, насколько оправданы оптимистичные прогнозы о влиянии этой технологии на эффективность работы программистов.

[![Дмитрий Нестерук «Разработка с использованием искусственного интеллекта»](images\ai-esse-part2-image-1.png)](https://www.youtube.com/watch?v=rmxRxpyYtZA "Дмитрий Нестерук «Разработка с использованием искусственного интеллекта»")

Кроме того, от знакомых я слышал, что сейчас появились модели с большим контекстом, в который может целиком поместиться код небольшого микросервиса. Такие модели могут значительно повысить качество генерируемого кода. Например, при запросе "добавь новое поле в ответ такого-то контроллера" ИИ может не только создать поле в DTO, но и добавить его в запрос к базе данных, а также автоматически сгенерировать миграцию для добавления этого поля в соответствующую таблицу. Это уже звучит значительно интереснее, чем простое написание тестов и документации. Так как я хотел попробовать разные инструменты, которые сейчас есть на рынке, я решил написать небольшой микросервисный проект. И начну я с создания шаблона микросервиса. Это позволит решить сразу две задачи:

Сэкономить время на добавлении однотипного кода в каждый новый сервис.
Создать для ИИ эталонный образец, на основе которого он сможет использовать нужный стиль кода, определенные пакеты и другие элементы, не придумывая всё с нуля.
В качестве ИИ я выбрал Claude. Причина выбора была проста: Claude предлагает функционал проектов, которые имеют достаточно большой контекст. Я создал решение добавил в него пустой проект AI.Template.cssproj и написал свой первый промт:

```
Ты опытный разработчик которому нужно написать шаблон, .net core решения для микросервисной архитектуры с использованием языка C# и версии 8 .net core. Пример вызова такого шаблона `dotnet new ai-template --projectName Project`. Сам код шаблона должен находиться в проекте AI.Template, а решение, созданное из шаблона, должно включать в себя следующие проекты: AI.Project.csproj, AI.Project.Host.csproj, AI.Project.Http.Contracts.csproj, AI.Project.Migrations.csproj, AI.Project.Entities.csproj. Параметр --projectName должен заменять часть Project в названии проектов. Проекты должны представлять различные слои приложения, такие как:
* AI.Project.csproj - проект библиотеки классов, содержащий код бизнес-логики приложения. Добавь в него ссылки на проекты AI.Project.Http.Contracts.csproj, AI.Project.Entities.csproj.
* AI.Project.Host.csproj - проект web api, содержащий код asp.net core хоста приложения. Добавь в него ссылку на проект AI.Project.csproj.
AI.Project.Http.Contracts.csproj - проект библиотеки классов, содержащий код Dto для синхронных контрактов приложения, используемых по протоколу http.
* AI.Project.Migrations.csproj - проект консольного приложения, выполняющий миграции БД. Добавь в него ссылки на проект AI.Project.Entities.csproj.
* AI.Project.Entities.csproj - проект библиотеки классов, содержащий код entity-классов для entity framework и DbContext приложения.
Все проекты, перечисленные выше, должны быть добавлены в решение AI.Project.sln.
```

Кроме того чтобы Claude мог полностью понять структуру решения, что такое AI.Project.sln и AI.Template.csproj, мне нужно было собрать весь код моего приложения в одном месте. Для этой задачи я использовал утилиту [ai-digest](https://github.com/khromov/ai-digest). Запустив ее в корневой директории проекта вы получите весь свой код объединенный в единый файл. Затем этот файл загружается в Claude в качестве контекста проекта. Что же в итоге я получил на выходе? Вполне корректный и правильный код, как самих файлов проекта, так и template.json, о необходимости которого я до начала работы имел самое смутное представление. Полностью вывод, я прилагать не буду из-за его длины, но выглядит это приблизительно вот так:

![Интерфейс проектов Claude](images\ai-esse-part1-image-2.PNG)

Итак, мы просто берем, копируем код и вставляем его в наши проекты, после чего создаем новый контекст для Claude, загружаем его, и повторяем все заново. Таким нехитрым способом я добавил следующую функциональность: конфигурацию хост-приложения на основе JSON-файлов, параметров командной строки, переменных окружения и пользовательских секретов, логирование в консоль и файл, версионирование API, feature Toggles, swagger, entity Framework и поддержку PostgreSQL для [проекта](https://github.com/gru/ai-template/tree/master/AI/Promts/Steps) миграций и в проект хоста, XUnit для тестов. И это лишь часть добавленного функционала. На самом деле, если бы тут был полный нумерованный список, он занял бы слишком много места. Поэтому его можно найти в репозитории проекта. 

Но задача добавления пакетов в решение, даже с их подключением в DI контейнер выглядит не очень сложной. Дальше пришло время написать код примеров в шаблоне, чтобы пользователю было понятно что и где лежит. Я попросил сгенерировать следующий код:

```
В нашем приложении бизнес-логика должна быть реализована в проекте AI.Project.csproj в файле AggregateHandler.cs. Он должен содержать два метода:
* Первый называется CreateAggregateAsync и принимает параметры name (имя агрегата) и cancellationToken. Он сохраняет новый AggregateEntity в базу данных при помощи ProjectDbContext и возвращает идентификатор сохраненной сущности.
* Второй называется GetAggregateAsync и принимает параметры id и cancellationToken. Он возвращает агрегат из базы данных при помощи ProjectDbContext. Если агрегат не найден, то метод бросает исключение InvalidOperationException.
Оба метода должны быть асинхронными и использовать переданный CancellationToken. 
Кроме того, нужно добавить статический класс ServiceCollectionExtensions с методом AddServices, который настраивает DI-контейнер, добавляя в него AggregateHandler с временем жизни Scoped.
```

И Claude справился очень неплохо. Тут я покажу уже конечный вариант, но он не сильно отличается от того что был изначально:

```csharp
using AI.ProjectName.Entities;
using AI.ProjectName.Http.Contracts;
using FluentValidation;

namespace AI.ProjectName.Aggregate;

public class AggregateHandler
{
    private readonly ProjectNameDbContext _dbContext;
    private readonly IValidator<CreateAggregateCommand> _validator;

    public AggregateHandler(ProjectNameDbContext dbContext, IValidator<CreateAggregateCommand> validator)
    {
        _dbContext = dbContext;
        _validator = validator;
    }

    public async Task<long> CreateAggregate(CreateAggregateCommand command, CancellationToken cancellationToken)
    {
        await _validator.ValidateAndThrowAsync(command, cancellationToken);

        var aggregate = new AggregateEntity
        {
            Name = command.Name
        };

        _dbContext.Aggregates.Add(aggregate);
        
        await _dbContext.SaveChangesAsync(cancellationToken);

        return aggregate.Id;
    }

    public async Task<AggregateEntity> GetAggregate(long id, CancellationToken cancellationToken)
    {
        var aggregate = await _dbContext.Aggregates.FindAsync([id], cancellationToken);
            
        if (aggregate == null)
        {
            throw new InvalidOperationException($"Aggregate with id {id} not found");
        }

        return aggregate;
    }
}
```

Помимо коротких и четких инструкций, ИИ понимает и довольно сложные скрипты, где в одном запросе мы просим его выполнить несколько разных действий. Не буду приводить пример такого промта в статье целиком, его можно найти в репозитории шаблона по [ссылке](https://github.com/gru/ai-template/blob/master/AI/Promts/Steps/11.%20Add-controller-sample.md). В нем я попросил ИИ выполнить следующие задачи: добавить команду в контрактную сборку, создать контроллер с двумя методами, соответствующими методам обработчика, добавить валидатор с правилами проверки, добавить feature toggle для API и добавить обработку исключения ValidationException в ProblemDetails.

```csharp
[ApiController]
[ApiVersion("1")]
[Route("api/v{version:apiVersion}/[controller]")]
[FeatureGate(FeatureToggles.ApiEnabled)]
public class AggregateController : ControllerBase
{
    private readonly AggregateHandler _aggregateHandler;

    public AggregateController(AggregateHandler aggregateHandler)
    {
        _aggregateHandler = aggregateHandler;
    }

    [HttpPost]
    public async Task<IActionResult> CreateAggregate([FromBody] CreateAggregateCommand command, CancellationToken cancellationToken)
    {
        var aggregateId = await _aggregateHandler.CreateAggregate(command, cancellationToken);
        return CreatedAtAction(nameof(GetAggregate), new { id = aggregateId }, aggregateId);
    }

    [HttpGet("{id:long}")]
    public async Task<ActionResult<AggregateDto>> GetAggregate(long id, CancellationToken cancellationToken)
    {
        var aggregate = await _aggregateHandler.GetAggregate(id, cancellationToken);
        return Ok(aggregate);
    }
}
```

При этом Claude оказался достаточно умным, чтобы автоматически создать AggregateDto и изменить обработчик AggregateHandler так, чтобы он начал возвращать его вместо AggregateEntity. Это не единственный пример, когда ИИ сделал чуть больше, чем я его просил, при этом его код в принципе укладывался в решение поставленной задачи. В другом случае, когда я попросил его создать тесты для контроллера, и Claude добавил настройку in-memory БД, хотя изначально я планировал, что тесты будут интеграционными с настоящей БД, поднятой в Docker. Но в принципе меня это решение устроило: для того чтобы показать пример шаблона микросервиса, это был неплохой вариант.

Про то, что ИИ удобно использовать для генерации README и CHANGELOG, я подробно рассказывать не буду, кроме того, что из ответа ИИ я узнал, что для создания CHANGELOG есть целый [стандарт](https://keepachangelog.com/en/1.0.0/).

Что же получилось в итоге? После того как я потратил около 8 часов на добавление всего, что я хотел, в шаблон, мне нужно было проверить, насколько его вообще можно использовать для создания нового сервиса. И естественно, после того как я его собрал, установил и вызвал команду `dotnet new ai-template`, ничего толкового не произошло. Пришлось дополнительно потратить около 4 часов на исправление ошибок и приведение конечного результата к тому, что я изначально хотел получить. 

Много это или мало? Смог бы я сделать быстрее самостоятельно? Думаю, что решение задачи заняло бы у меня приблизительно столько же времени. Но сам процесс разработки при помощи ИИ довольно сильно отличается от привычного. В основном всё сводится к подготовке промта и это заставляет думать немного вперед, формулируя свои мысли до того, как собственно появится сам код. При этом сразу всплывают вещи, которые пропустил. Например, создавать DTO и маппить его свойства в обработчике странно до того, как сделал таблицу в БД. ИИ навязывает более аналитический подход к решению задач.

В любом случае, ИИ - это очень интересная тема, и в следующих статьях я хочу попробовать создать сервис на основе моего шаблона (на момент написания статьи сам сервис готов, и его можно посмотреть по [ссылке](https://github.com/gru/ai-storage)), конвертировать сервис, который написан на языке, отличном от C#, на .NET Core, попробовать другие модели (как минимум, сейчас много говорят о том, что ChatGPT с моделью GPT-4 умеет неплохо писать код), и попробовать использовать ИИ как junior-программист на незнакомом для меня языке и в незнакомой области, чтобы понять, что можно сделать в случае, если мало понимаешь в программировании. Например, написать какой-то frontend на новом для меня фреймворке.  Кроме того хотелось бы посмотреть поближе на Cursor AI чтобы избавиться от необходимости копировать код между браузером и IDE.